#!/usr/bin/env node

var fs = require('fs'),
	path = require('path'),
	child_process = require('child_process'),
	async = require('async'),
	_ = require('lodash-node'),
	glob = require('glob');

var noop = _.contains(process.argv, '--noop');

var args, dir;
if (fs.existsSync('package.json')) {
	args = [ './package.json' ];
	dir = '../';
} else {
	args = glob.sync('*/package.json');
	dir = './';
}
dir = path.join(process.cwd(), dir);


function plural(count, word) {
	return count + ' ' + (count > 1 ? word + 's' : word);
}

function exec(cmd, args, cwd, cb) {
	if (cb == null) {
		cb = cwd;
		cwd = undefined;
	}
	var proc = child_process.spawn(cmd, args, {
		cwd: cwd,
		stdio: ['ignore', process.stdout, process.stderr]
	});
	proc.on('close', function (code) {
		var e = null;
		if (code !== 0) {
			e = new Error(cmd + ' returned ' + code);
		}
		cb(e);
	});
}

var projects = {};
var matchers = {};

function expectedPath(url) {
	return path.join(dir, path.basename(url).replace(/\.git$/, ""));
}

function normalizeGitUrl(url) {
	return url.replace(/(git\+ssh:\/\/)?([^#]*)(#.*)?$/, '$2');
}

function shouldLink(url) {
	return _.any(matchers, function (matcher) {
		return matcher.test(url);
	});
}

function readJson(file, cb) {
	fs.readFile(file, function (err, data) {
		if (err) return cb(err);
		try {
			cb(null, JSON.parse(data));
		} catch (e) {
			return cb(e);
		}
	});
}

function matchersFromFile(file, cb) {
	var dir = path.dirname(file);
	child_process.exec('git config --get remote.origin.url', { cwd: dir }, function (err, stdout, stderr) {
		if (err) return cb(err);

		var pattern = path.dirname(stdout.trim());
		matchers[pattern] = new RegExp(pattern);
		cb();
	});
}

function projectFromFile(file, cb) {
	readJson(file, function (err, json) {
		if (err) return cb(err);

		var project = projects[json.name] = {
			name: json.name,
			path: path.dirname(path.resolve(file)),
			exists: true,
			deps: []
		};
		_.each(json.dependencies, function (version, name) {
			if (shouldLink(version)) {
				project.deps.push(name);
				if (!projects[name]) {
					var url = normalizeGitUrl(version);
					projects[name] = {
						name: name,
						url: url,
						path: expectedPath(url)
					};
				}
			}
		});
		cb(null, project);
	});
}

function cloneIfMissing(project, cb) {
	if (project.exists) {
		cb();
	} else if (!fs.existsSync(project.path)) {
		if (noop) {
			console.log('(skipped) git clone ' + project.url + ' ' + project.path);
			project.exists = true;
			cb();
		} else {
			exec('git', ['clone', project.url, project.path], cb);
		}
	} else {
		projectFromFile(path.join(project.path, 'package.json'), cb);
	}
}

function linkDependencies(project, cb) {
	console.log('>>> linking modules for ' + project.name);

	async.eachSeries(project.deps, function (dep, cb) {
		var dependent = projects[dep];
		var relative = path.relative(project.path, dependent.path);
		var module = path.join(project.path, 'node_modules', dependent.name);
		if (fs.existsSync(module) && fs.lstatSync(module).isSymbolicLink()) {
			return cb();
		}
		dependent.installed = true;
		if (noop) {
			console.log('(skipped) npm link ' + relative + ' [cwd=' + project.path + ']');
			cb();
		} else {
			exec('npm', ['link', relative], project.path, cb);
		}
	}, cb);
}

function installProject(project, cb) {
	if (project.installed) {
		console.log('>>> npm install for ' + project.name + ' skipped because it was the target of a npm link');
		cb();
	} else {
		console.log('>>> npm install for ' + project.name);
		project.installed = true;
		if (noop) {
			console.log('(skipped) npm install [cwd=' + project.path + ']');
			cb();
		} else {
			exec('npm', ['install'], project.path, cb);
		}
	}
}

console.log('>>> starting with ' + plural(args.length, 'project') + ' in ' + dir);

async.waterfall([
	function (cb) {
		async.each(args, matchersFromFile, cb);
	},
	function (cb) {
		console.log('>>> looking for dependencies matching', Object.keys(matchers));

		async.each(args, projectFromFile, cb);
	},
	function (cb) {
		async.until(function () {
			return _.all(projects, 'exists');
		}, function (cb) {
			async.eachSeries(_.values(projects), cloneIfMissing, cb);
		}, cb);
	},
	function (cb) {
		async.eachSeries(_.values(projects), linkDependencies, cb);
	},
	function (cb) {
		async.eachSeries(_.values(projects), installProject, cb);
	}
], function (err) {
	if (err) throw err;

	console.log('>>> ended with ' + plural(_.size(projects), 'project') + ' in ' + dir);
});
